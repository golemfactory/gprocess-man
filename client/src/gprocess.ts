// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.27.3
// source: gprocess.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";
import Long = require("long");

export const protobufPackage = "gprocess.api";

export enum Stream {
  NULL = 0,
  PIPE = 1,
  INHERIT = 2,
  UNRECOGNIZED = -1,
}

export function streamFromJSON(object: any): Stream {
  switch (object) {
    case 0:
    case "NULL":
      return Stream.NULL;
    case 1:
    case "PIPE":
      return Stream.PIPE;
    case 2:
    case "INHERIT":
      return Stream.INHERIT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Stream.UNRECOGNIZED;
  }
}

export function streamToJSON(object: Stream): string {
  switch (object) {
    case Stream.NULL:
      return "NULL";
    case Stream.PIPE:
      return "PIPE";
    case Stream.INHERIT:
      return "INHERIT";
    case Stream.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Error {
  message: string;
}

export interface Env {
  name: Uint8Array;
  value?: Uint8Array | undefined;
}

export interface Request {
  requestId: number;
  command?:
    | { $case: "start"; start: StartRequest }
    | { $case: "signal"; signal: SignalRequest }
    | { $case: "wait"; wait: WaitRequest }
    | { $case: "read"; read: ReadRequest }
    | { $case: "write"; write: WriteRequest }
    | { $case: "ps"; ps: PsRequest }
    | { $case: "close"; close: CloseRequest }
    | undefined;
}

export interface Response {
  requestId: number;
  command?:
    | { $case: "start"; start: StartResponse }
    | { $case: "signal"; signal: SignalResponse }
    | { $case: "wait"; wait: WaitResponse }
    | { $case: "read"; read: ReadResponse }
    | { $case: "write"; write: WriteResponse }
    | { $case: "ps"; ps: PsResponse }
    | { $case: "close"; close: CloseResponse }
    | { $case: "error"; error: Error }
    | undefined;
}

export interface StartRequest {
  program: string;
  args: Uint8Array[];
  uid?: number | undefined;
  gid?: number | undefined;
  workDir?: Uint8Array | undefined;
  envClear?: boolean | undefined;
  env: Env[];
  stdin?: Stream | undefined;
  stdout?: Stream | undefined;
  stderr?: Stream | undefined;
}

export interface SignalRequest {
  pid: number;
  signal: number;
}

export interface WaitRequest {
  pid: number;
}

export interface ReadRequest {
  pid: number;
  stream: number;
  len: number;
}

export interface WriteRequest {
  pid: number;
  stream: number;
  data: Uint8Array;
}

export interface PsRequest {
}

export interface CloseRequest {
  pid: number;
}

export interface StartResponse {
  pid: number;
  stdin?: number | undefined;
  stdout?: number | undefined;
  stderr?: number | undefined;
}

export interface SignalResponse {
}

export interface WaitResponse {
  status?: number | undefined;
  alreadyWaits?: boolean | undefined;
}

export interface ReadResponse {
  data: Uint8Array;
}

export interface WriteResponse {
  len: number;
}

export interface PsResponse {
  pid: number[];
}

export interface CloseResponse {
}

export interface Process {
  pid: number;
}

export interface ProcessInfo {
  pid: number;
  name?: string | undefined;
  path?: string | undefined;
}

function createBaseError(): Error {
  return { message: "" };
}

export const Error = {
  encode(message: Error, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Error {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: Error): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Error>, I>>(base?: I): Error {
    return Error.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Error>, I>>(object: I): Error {
    const message = createBaseError();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseEnv(): Env {
  return { name: new Uint8Array(0), value: new Uint8Array(0) };
}

export const Env = {
  encode(message: Env, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name.length !== 0) {
      writer.uint32(10).bytes(message.name);
    }
    if (message.value !== undefined && message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Env {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnv();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Env {
    return {
      name: isSet(object.name) ? bytesFromBase64(object.name) : new Uint8Array(0),
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: Env): unknown {
    const obj: any = {};
    if (message.name.length !== 0) {
      obj.name = base64FromBytes(message.name);
    }
    if (message.value !== undefined && message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Env>, I>>(base?: I): Env {
    return Env.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Env>, I>>(object: I): Env {
    const message = createBaseEnv();
    message.name = object.name ?? new Uint8Array(0);
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRequest(): Request {
  return { requestId: 0, command: undefined };
}

export const Request = {
  encode(message: Request, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.requestId !== 0) {
      writer.uint32(8).uint32(message.requestId);
    }
    switch (message.command?.$case) {
      case "start":
        StartRequest.encode(message.command.start, writer.uint32(18).fork()).ldelim();
        break;
      case "signal":
        SignalRequest.encode(message.command.signal, writer.uint32(26).fork()).ldelim();
        break;
      case "wait":
        WaitRequest.encode(message.command.wait, writer.uint32(34).fork()).ldelim();
        break;
      case "read":
        ReadRequest.encode(message.command.read, writer.uint32(42).fork()).ldelim();
        break;
      case "write":
        WriteRequest.encode(message.command.write, writer.uint32(50).fork()).ldelim();
        break;
      case "ps":
        PsRequest.encode(message.command.ps, writer.uint32(58).fork()).ldelim();
        break;
      case "close":
        CloseRequest.encode(message.command.close, writer.uint32(66).fork()).ldelim();
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Request {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.requestId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.command = { $case: "start", start: StartRequest.decode(reader, reader.uint32()) };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.command = { $case: "signal", signal: SignalRequest.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.command = { $case: "wait", wait: WaitRequest.decode(reader, reader.uint32()) };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.command = { $case: "read", read: ReadRequest.decode(reader, reader.uint32()) };
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.command = { $case: "write", write: WriteRequest.decode(reader, reader.uint32()) };
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.command = { $case: "ps", ps: PsRequest.decode(reader, reader.uint32()) };
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.command = { $case: "close", close: CloseRequest.decode(reader, reader.uint32()) };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Request {
    return {
      requestId: isSet(object.requestId) ? globalThis.Number(object.requestId) : 0,
      command: isSet(object.start)
        ? { $case: "start", start: StartRequest.fromJSON(object.start) }
        : isSet(object.signal)
        ? { $case: "signal", signal: SignalRequest.fromJSON(object.signal) }
        : isSet(object.wait)
        ? { $case: "wait", wait: WaitRequest.fromJSON(object.wait) }
        : isSet(object.read)
        ? { $case: "read", read: ReadRequest.fromJSON(object.read) }
        : isSet(object.write)
        ? { $case: "write", write: WriteRequest.fromJSON(object.write) }
        : isSet(object.ps)
        ? { $case: "ps", ps: PsRequest.fromJSON(object.ps) }
        : isSet(object.close)
        ? { $case: "close", close: CloseRequest.fromJSON(object.close) }
        : undefined,
    };
  },

  toJSON(message: Request): unknown {
    const obj: any = {};
    if (message.requestId !== 0) {
      obj.requestId = Math.round(message.requestId);
    }
    if (message.command?.$case === "start") {
      obj.start = StartRequest.toJSON(message.command.start);
    }
    if (message.command?.$case === "signal") {
      obj.signal = SignalRequest.toJSON(message.command.signal);
    }
    if (message.command?.$case === "wait") {
      obj.wait = WaitRequest.toJSON(message.command.wait);
    }
    if (message.command?.$case === "read") {
      obj.read = ReadRequest.toJSON(message.command.read);
    }
    if (message.command?.$case === "write") {
      obj.write = WriteRequest.toJSON(message.command.write);
    }
    if (message.command?.$case === "ps") {
      obj.ps = PsRequest.toJSON(message.command.ps);
    }
    if (message.command?.$case === "close") {
      obj.close = CloseRequest.toJSON(message.command.close);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Request>, I>>(base?: I): Request {
    return Request.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Request>, I>>(object: I): Request {
    const message = createBaseRequest();
    message.requestId = object.requestId ?? 0;
    if (object.command?.$case === "start" && object.command?.start !== undefined && object.command?.start !== null) {
      message.command = { $case: "start", start: StartRequest.fromPartial(object.command.start) };
    }
    if (object.command?.$case === "signal" && object.command?.signal !== undefined && object.command?.signal !== null) {
      message.command = { $case: "signal", signal: SignalRequest.fromPartial(object.command.signal) };
    }
    if (object.command?.$case === "wait" && object.command?.wait !== undefined && object.command?.wait !== null) {
      message.command = { $case: "wait", wait: WaitRequest.fromPartial(object.command.wait) };
    }
    if (object.command?.$case === "read" && object.command?.read !== undefined && object.command?.read !== null) {
      message.command = { $case: "read", read: ReadRequest.fromPartial(object.command.read) };
    }
    if (object.command?.$case === "write" && object.command?.write !== undefined && object.command?.write !== null) {
      message.command = { $case: "write", write: WriteRequest.fromPartial(object.command.write) };
    }
    if (object.command?.$case === "ps" && object.command?.ps !== undefined && object.command?.ps !== null) {
      message.command = { $case: "ps", ps: PsRequest.fromPartial(object.command.ps) };
    }
    if (object.command?.$case === "close" && object.command?.close !== undefined && object.command?.close !== null) {
      message.command = { $case: "close", close: CloseRequest.fromPartial(object.command.close) };
    }
    return message;
  },
};

function createBaseResponse(): Response {
  return { requestId: 0, command: undefined };
}

export const Response = {
  encode(message: Response, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.requestId !== 0) {
      writer.uint32(8).uint32(message.requestId);
    }
    switch (message.command?.$case) {
      case "start":
        StartResponse.encode(message.command.start, writer.uint32(18).fork()).ldelim();
        break;
      case "signal":
        SignalResponse.encode(message.command.signal, writer.uint32(26).fork()).ldelim();
        break;
      case "wait":
        WaitResponse.encode(message.command.wait, writer.uint32(34).fork()).ldelim();
        break;
      case "read":
        ReadResponse.encode(message.command.read, writer.uint32(42).fork()).ldelim();
        break;
      case "write":
        WriteResponse.encode(message.command.write, writer.uint32(50).fork()).ldelim();
        break;
      case "ps":
        PsResponse.encode(message.command.ps, writer.uint32(58).fork()).ldelim();
        break;
      case "close":
        CloseResponse.encode(message.command.close, writer.uint32(66).fork()).ldelim();
        break;
      case "error":
        Error.encode(message.command.error, writer.uint32(794).fork()).ldelim();
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Response {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.requestId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.command = { $case: "start", start: StartResponse.decode(reader, reader.uint32()) };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.command = { $case: "signal", signal: SignalResponse.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.command = { $case: "wait", wait: WaitResponse.decode(reader, reader.uint32()) };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.command = { $case: "read", read: ReadResponse.decode(reader, reader.uint32()) };
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.command = { $case: "write", write: WriteResponse.decode(reader, reader.uint32()) };
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.command = { $case: "ps", ps: PsResponse.decode(reader, reader.uint32()) };
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.command = { $case: "close", close: CloseResponse.decode(reader, reader.uint32()) };
          continue;
        case 99:
          if (tag !== 794) {
            break;
          }

          message.command = { $case: "error", error: Error.decode(reader, reader.uint32()) };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Response {
    return {
      requestId: isSet(object.requestId) ? globalThis.Number(object.requestId) : 0,
      command: isSet(object.start)
        ? { $case: "start", start: StartResponse.fromJSON(object.start) }
        : isSet(object.signal)
        ? { $case: "signal", signal: SignalResponse.fromJSON(object.signal) }
        : isSet(object.wait)
        ? { $case: "wait", wait: WaitResponse.fromJSON(object.wait) }
        : isSet(object.read)
        ? { $case: "read", read: ReadResponse.fromJSON(object.read) }
        : isSet(object.write)
        ? { $case: "write", write: WriteResponse.fromJSON(object.write) }
        : isSet(object.ps)
        ? { $case: "ps", ps: PsResponse.fromJSON(object.ps) }
        : isSet(object.close)
        ? { $case: "close", close: CloseResponse.fromJSON(object.close) }
        : isSet(object.error)
        ? { $case: "error", error: Error.fromJSON(object.error) }
        : undefined,
    };
  },

  toJSON(message: Response): unknown {
    const obj: any = {};
    if (message.requestId !== 0) {
      obj.requestId = Math.round(message.requestId);
    }
    if (message.command?.$case === "start") {
      obj.start = StartResponse.toJSON(message.command.start);
    }
    if (message.command?.$case === "signal") {
      obj.signal = SignalResponse.toJSON(message.command.signal);
    }
    if (message.command?.$case === "wait") {
      obj.wait = WaitResponse.toJSON(message.command.wait);
    }
    if (message.command?.$case === "read") {
      obj.read = ReadResponse.toJSON(message.command.read);
    }
    if (message.command?.$case === "write") {
      obj.write = WriteResponse.toJSON(message.command.write);
    }
    if (message.command?.$case === "ps") {
      obj.ps = PsResponse.toJSON(message.command.ps);
    }
    if (message.command?.$case === "close") {
      obj.close = CloseResponse.toJSON(message.command.close);
    }
    if (message.command?.$case === "error") {
      obj.error = Error.toJSON(message.command.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Response>, I>>(base?: I): Response {
    return Response.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Response>, I>>(object: I): Response {
    const message = createBaseResponse();
    message.requestId = object.requestId ?? 0;
    if (object.command?.$case === "start" && object.command?.start !== undefined && object.command?.start !== null) {
      message.command = { $case: "start", start: StartResponse.fromPartial(object.command.start) };
    }
    if (object.command?.$case === "signal" && object.command?.signal !== undefined && object.command?.signal !== null) {
      message.command = { $case: "signal", signal: SignalResponse.fromPartial(object.command.signal) };
    }
    if (object.command?.$case === "wait" && object.command?.wait !== undefined && object.command?.wait !== null) {
      message.command = { $case: "wait", wait: WaitResponse.fromPartial(object.command.wait) };
    }
    if (object.command?.$case === "read" && object.command?.read !== undefined && object.command?.read !== null) {
      message.command = { $case: "read", read: ReadResponse.fromPartial(object.command.read) };
    }
    if (object.command?.$case === "write" && object.command?.write !== undefined && object.command?.write !== null) {
      message.command = { $case: "write", write: WriteResponse.fromPartial(object.command.write) };
    }
    if (object.command?.$case === "ps" && object.command?.ps !== undefined && object.command?.ps !== null) {
      message.command = { $case: "ps", ps: PsResponse.fromPartial(object.command.ps) };
    }
    if (object.command?.$case === "close" && object.command?.close !== undefined && object.command?.close !== null) {
      message.command = { $case: "close", close: CloseResponse.fromPartial(object.command.close) };
    }
    if (object.command?.$case === "error" && object.command?.error !== undefined && object.command?.error !== null) {
      message.command = { $case: "error", error: Error.fromPartial(object.command.error) };
    }
    return message;
  },
};

function createBaseStartRequest(): StartRequest {
  return {
    program: "",
    args: [],
    env: [],
  };
}

export const StartRequest = {
  encode(message: StartRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.program !== "") {
      writer.uint32(10).string(message.program);
    }
    for (const v of message.args) {
      writer.uint32(18).bytes(v!);
    }
    if (message.uid !== undefined && message.uid !== 0) {
      writer.uint32(24).uint32(message.uid);
    }
    if (message.gid !== undefined && message.gid !== 0) {
      writer.uint32(32).uint32(message.gid);
    }
    if (message.workDir !== undefined && message.workDir.length !== 0) {
      writer.uint32(42).bytes(message.workDir);
    }
    if (message.envClear !== undefined && message.envClear !== false) {
      writer.uint32(48).bool(message.envClear);
    }
    for (const v of message.env) {
      Env.encode(v!, writer.uint32(82).fork()).ldelim();
    }
    if (message.stdin !== undefined && message.stdin !== 0) {
      writer.uint32(88).int32(message.stdin);
    }
    if (message.stdout !== undefined && message.stdout !== 0) {
      writer.uint32(96).int32(message.stdout);
    }
    if (message.stderr !== undefined && message.stderr !== 0) {
      writer.uint32(104).int32(message.stderr);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.program = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.args.push(reader.bytes());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.uid = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.gid = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.workDir = reader.bytes();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.envClear = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.env.push(Env.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.stdin = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.stdout = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.stderr = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartRequest {
    return {
      program: isSet(object.program) ? globalThis.String(object.program) : "",
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => bytesFromBase64(e)) : [],
      uid: isSet(object.uid) ? globalThis.Number(object.uid) : 0,
      gid: isSet(object.gid) ? globalThis.Number(object.gid) : 0,
      workDir: isSet(object.workDir) ? bytesFromBase64(object.workDir) : new Uint8Array(0),
      envClear: isSet(object.envClear) ? globalThis.Boolean(object.envClear) : false,
      env: globalThis.Array.isArray(object?.env) ? object.env.map((e: any) => Env.fromJSON(e)) : [],
      stdin: isSet(object.stdin) ? streamFromJSON(object.stdin) : 0,
      stdout: isSet(object.stdout) ? streamFromJSON(object.stdout) : 0,
      stderr: isSet(object.stderr) ? streamFromJSON(object.stderr) : 0,
    };
  },

  toJSON(message: StartRequest): unknown {
    const obj: any = {};
    if (message.program !== "") {
      obj.program = message.program;
    }
    if (message.args?.length) {
      obj.args = message.args.map((e) => base64FromBytes(e));
    }
    if (message.uid !== undefined && message.uid !== 0) {
      obj.uid = Math.round(message.uid);
    }
    if (message.gid !== undefined && message.gid !== 0) {
      obj.gid = Math.round(message.gid);
    }
    if (message.workDir !== undefined && message.workDir.length !== 0) {
      obj.workDir = base64FromBytes(message.workDir);
    }
    if (message.envClear !== undefined && message.envClear !== false) {
      obj.envClear = message.envClear;
    }
    if (message.env?.length) {
      obj.env = message.env.map((e) => Env.toJSON(e));
    }
    if (message.stdin !== undefined && message.stdin !== 0) {
      obj.stdin = streamToJSON(message.stdin);
    }
    if (message.stdout !== undefined && message.stdout !== 0) {
      obj.stdout = streamToJSON(message.stdout);
    }
    if (message.stderr !== undefined && message.stderr !== 0) {
      obj.stderr = streamToJSON(message.stderr);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StartRequest>, I>>(base?: I): StartRequest {
    return StartRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartRequest>, I>>(object: I): StartRequest {
    const message = createBaseStartRequest();
    message.program = object.program ?? "";
    message.args = object.args?.map((e) => e) || [];
    message.uid = object.uid ?? 0;
    message.gid = object.gid ?? 0;
    message.workDir = object.workDir ?? new Uint8Array(0);
    message.envClear = object.envClear ?? false;
    message.env = object.env?.map((e) => Env.fromPartial(e)) || [];
    message.stdin = object.stdin ?? 0;
    message.stdout = object.stdout ?? 0;
    message.stderr = object.stderr ?? 0;
    return message;
  },
};

function createBaseSignalRequest(): SignalRequest {
  return { pid: 0, signal: 0 };
}

export const SignalRequest = {
  encode(message: SignalRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pid !== 0) {
      writer.uint32(8).uint64(message.pid);
    }
    if (message.signal !== 0) {
      writer.uint32(16).int32(message.signal);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SignalRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pid = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.signal = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignalRequest {
    return {
      pid: isSet(object.pid) ? globalThis.Number(object.pid) : 0,
      signal: isSet(object.signal) ? globalThis.Number(object.signal) : 0,
    };
  },

  toJSON(message: SignalRequest): unknown {
    const obj: any = {};
    if (message.pid !== 0) {
      obj.pid = Math.round(message.pid);
    }
    if (message.signal !== 0) {
      obj.signal = Math.round(message.signal);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignalRequest>, I>>(base?: I): SignalRequest {
    return SignalRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignalRequest>, I>>(object: I): SignalRequest {
    const message = createBaseSignalRequest();
    message.pid = object.pid ?? 0;
    message.signal = object.signal ?? 0;
    return message;
  },
};

function createBaseWaitRequest(): WaitRequest {
  return { pid: 0 };
}

export const WaitRequest = {
  encode(message: WaitRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pid !== 0) {
      writer.uint32(8).uint64(message.pid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WaitRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWaitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pid = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WaitRequest {
    return { pid: isSet(object.pid) ? globalThis.Number(object.pid) : 0 };
  },

  toJSON(message: WaitRequest): unknown {
    const obj: any = {};
    if (message.pid !== 0) {
      obj.pid = Math.round(message.pid);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WaitRequest>, I>>(base?: I): WaitRequest {
    return WaitRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WaitRequest>, I>>(object: I): WaitRequest {
    const message = createBaseWaitRequest();
    message.pid = object.pid ?? 0;
    return message;
  },
};

function createBaseReadRequest(): ReadRequest {
  return { pid: 0, stream: 0, len: 0 };
}

export const ReadRequest = {
  encode(message: ReadRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pid !== 0) {
      writer.uint32(8).uint64(message.pid);
    }
    if (message.stream !== 0) {
      writer.uint32(16).int32(message.stream);
    }
    if (message.len !== 0) {
      writer.uint32(24).uint32(message.len);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReadRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pid = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.stream = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.len = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadRequest {
    return {
      pid: isSet(object.pid) ? globalThis.Number(object.pid) : 0,
      stream: isSet(object.stream) ? globalThis.Number(object.stream) : 0,
      len: isSet(object.len) ? globalThis.Number(object.len) : 0,
    };
  },

  toJSON(message: ReadRequest): unknown {
    const obj: any = {};
    if (message.pid !== 0) {
      obj.pid = Math.round(message.pid);
    }
    if (message.stream !== 0) {
      obj.stream = Math.round(message.stream);
    }
    if (message.len !== 0) {
      obj.len = Math.round(message.len);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadRequest>, I>>(base?: I): ReadRequest {
    return ReadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadRequest>, I>>(object: I): ReadRequest {
    const message = createBaseReadRequest();
    message.pid = object.pid ?? 0;
    message.stream = object.stream ?? 0;
    message.len = object.len ?? 0;
    return message;
  },
};

function createBaseWriteRequest(): WriteRequest {
  return { pid: 0, stream: 0, data: new Uint8Array(0) };
}

export const WriteRequest = {
  encode(message: WriteRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pid !== 0) {
      writer.uint32(8).uint64(message.pid);
    }
    if (message.stream !== 0) {
      writer.uint32(16).int32(message.stream);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WriteRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pid = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.stream = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WriteRequest {
    return {
      pid: isSet(object.pid) ? globalThis.Number(object.pid) : 0,
      stream: isSet(object.stream) ? globalThis.Number(object.stream) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: WriteRequest): unknown {
    const obj: any = {};
    if (message.pid !== 0) {
      obj.pid = Math.round(message.pid);
    }
    if (message.stream !== 0) {
      obj.stream = Math.round(message.stream);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WriteRequest>, I>>(base?: I): WriteRequest {
    return WriteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WriteRequest>, I>>(object: I): WriteRequest {
    const message = createBaseWriteRequest();
    message.pid = object.pid ?? 0;
    message.stream = object.stream ?? 0;
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBasePsRequest(): PsRequest {
  return {};
}

export const PsRequest = {
  encode(_: PsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PsRequest {
    return {};
  },

  toJSON(_: PsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PsRequest>, I>>(base?: I): PsRequest {
    return PsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PsRequest>, I>>(_: I): PsRequest {
    const message = createBasePsRequest();
    return message;
  },
};

function createBaseCloseRequest(): CloseRequest {
  return { pid: 0 };
}

export const CloseRequest = {
  encode(message: CloseRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pid !== 0) {
      writer.uint32(8).uint64(message.pid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CloseRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pid = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloseRequest {
    return { pid: isSet(object.pid) ? globalThis.Number(object.pid) : 0 };
  },

  toJSON(message: CloseRequest): unknown {
    const obj: any = {};
    if (message.pid !== 0) {
      obj.pid = Math.round(message.pid);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CloseRequest>, I>>(base?: I): CloseRequest {
    return CloseRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CloseRequest>, I>>(object: I): CloseRequest {
    const message = createBaseCloseRequest();
    message.pid = object.pid ?? 0;
    return message;
  },
};

function createBaseStartResponse(): StartResponse {
  return { pid: 0 };
}

export const StartResponse = {
  encode(message: StartResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pid !== 0) {
      writer.uint32(8).uint64(message.pid);
    }
    if (message.stdin !== undefined && message.stdin !== 0) {
      writer.uint32(80).int32(message.stdin);
    }
    if (message.stdout !== undefined && message.stdout !== 0) {
      writer.uint32(88).int32(message.stdout);
    }
    if (message.stderr !== undefined && message.stderr !== 0) {
      writer.uint32(96).int32(message.stderr);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pid = longToNumber(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.stdin = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.stdout = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.stderr = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartResponse {
    return {
      pid: isSet(object.pid) ? globalThis.Number(object.pid) : 0,
      stdin: isSet(object.stdin) ? globalThis.Number(object.stdin) : 0,
      stdout: isSet(object.stdout) ? globalThis.Number(object.stdout) : 0,
      stderr: isSet(object.stderr) ? globalThis.Number(object.stderr) : 0,
    };
  },

  toJSON(message: StartResponse): unknown {
    const obj: any = {};
    if (message.pid !== 0) {
      obj.pid = Math.round(message.pid);
    }
    if (message.stdin !== undefined && message.stdin !== 0) {
      obj.stdin = Math.round(message.stdin);
    }
    if (message.stdout !== undefined && message.stdout !== 0) {
      obj.stdout = Math.round(message.stdout);
    }
    if (message.stderr !== undefined && message.stderr !== 0) {
      obj.stderr = Math.round(message.stderr);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StartResponse>, I>>(base?: I): StartResponse {
    return StartResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartResponse>, I>>(object: I): StartResponse {
    const message = createBaseStartResponse();
    message.pid = object.pid ?? 0;
    message.stdin = object.stdin ?? 0;
    message.stdout = object.stdout ?? 0;
    message.stderr = object.stderr ?? 0;
    return message;
  },
};

function createBaseSignalResponse(): SignalResponse {
  return {};
}

export const SignalResponse = {
  encode(_: SignalResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SignalResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SignalResponse {
    return {};
  },

  toJSON(_: SignalResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SignalResponse>, I>>(base?: I): SignalResponse {
    return SignalResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignalResponse>, I>>(_: I): SignalResponse {
    const message = createBaseSignalResponse();
    return message;
  },
};

function createBaseWaitResponse(): WaitResponse {
  return {};
}

export const WaitResponse = {
  encode(message: WaitResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== undefined && message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.alreadyWaits !== undefined && message.alreadyWaits !== false) {
      writer.uint32(16).bool(message.alreadyWaits);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WaitResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWaitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.alreadyWaits = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WaitResponse {
    return {
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      alreadyWaits: isSet(object.alreadyWaits) ? globalThis.Boolean(object.alreadyWaits) : false,
    };
  },

  toJSON(message: WaitResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined && message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.alreadyWaits !== undefined && message.alreadyWaits !== false) {
      obj.alreadyWaits = message.alreadyWaits;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WaitResponse>, I>>(base?: I): WaitResponse {
    return WaitResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WaitResponse>, I>>(object: I): WaitResponse {
    const message = createBaseWaitResponse();
    message.status = object.status ?? 0;
    message.alreadyWaits = object.alreadyWaits ?? false;
    return message;
  },
};

function createBaseReadResponse(): ReadResponse {
  return { data: new Uint8Array(0) };
}

export const ReadResponse = {
  encode(message: ReadResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReadResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadResponse {
    return { data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0) };
  },

  toJSON(message: ReadResponse): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadResponse>, I>>(base?: I): ReadResponse {
    return ReadResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadResponse>, I>>(object: I): ReadResponse {
    const message = createBaseReadResponse();
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWriteResponse(): WriteResponse {
  return { len: 0 };
}

export const WriteResponse = {
  encode(message: WriteResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.len !== 0) {
      writer.uint32(8).uint32(message.len);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WriteResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.len = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WriteResponse {
    return { len: isSet(object.len) ? globalThis.Number(object.len) : 0 };
  },

  toJSON(message: WriteResponse): unknown {
    const obj: any = {};
    if (message.len !== 0) {
      obj.len = Math.round(message.len);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WriteResponse>, I>>(base?: I): WriteResponse {
    return WriteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WriteResponse>, I>>(object: I): WriteResponse {
    const message = createBaseWriteResponse();
    message.len = object.len ?? 0;
    return message;
  },
};

function createBasePsResponse(): PsResponse {
  return { pid: [] };
}

export const PsResponse = {
  encode(message: PsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.pid) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.pid.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.pid.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PsResponse {
    return { pid: globalThis.Array.isArray(object?.pid) ? object.pid.map((e: any) => globalThis.Number(e)) : [] };
  },

  toJSON(message: PsResponse): unknown {
    const obj: any = {};
    if (message.pid?.length) {
      obj.pid = message.pid.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PsResponse>, I>>(base?: I): PsResponse {
    return PsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PsResponse>, I>>(object: I): PsResponse {
    const message = createBasePsResponse();
    message.pid = object.pid?.map((e) => e) || [];
    return message;
  },
};

function createBaseCloseResponse(): CloseResponse {
  return {};
}

export const CloseResponse = {
  encode(_: CloseResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CloseResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CloseResponse {
    return {};
  },

  toJSON(_: CloseResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CloseResponse>, I>>(base?: I): CloseResponse {
    return CloseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CloseResponse>, I>>(_: I): CloseResponse {
    const message = createBaseCloseResponse();
    return message;
  },
};

function createBaseProcess(): Process {
  return { pid: 0 };
}

export const Process = {
  encode(message: Process, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pid !== 0) {
      writer.uint32(8).uint64(message.pid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Process {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pid = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Process {
    return { pid: isSet(object.pid) ? globalThis.Number(object.pid) : 0 };
  },

  toJSON(message: Process): unknown {
    const obj: any = {};
    if (message.pid !== 0) {
      obj.pid = Math.round(message.pid);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Process>, I>>(base?: I): Process {
    return Process.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Process>, I>>(object: I): Process {
    const message = createBaseProcess();
    message.pid = object.pid ?? 0;
    return message;
  },
};

function createBaseProcessInfo(): ProcessInfo {
  return { pid: 0, name: "", path: "" };
}

export const ProcessInfo = {
  encode(message: ProcessInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pid !== 0) {
      writer.uint32(8).uint64(message.pid);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.path !== undefined && message.path !== "") {
      writer.uint32(26).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProcessInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pid = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessInfo {
    return {
      pid: isSet(object.pid) ? globalThis.Number(object.pid) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: ProcessInfo): unknown {
    const obj: any = {};
    if (message.pid !== 0) {
      obj.pid = Math.round(message.pid);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.path !== undefined && message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessInfo>, I>>(base?: I): ProcessInfo {
    return ProcessInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessInfo>, I>>(object: I): ProcessInfo {
    const message = createBaseProcessInfo();
    message.pid = object.pid ?? 0;
    message.name = object.name ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
